
#include "../../Internal.h"
#include "X11Window.h"

namespace Lumino
{
namespace Platform
{

//=============================================================================
// X11Window
//=============================================================================

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
X11Window::X11Window(X11WindowManager* windowManager, const SettingData& settingData)
	: WindowBase(windowManager)
	, m_x11Window(NULL)
{
	m_titleText = settingData.TitleText;
	m_clientSize = ClientSize;
	
	Display*	x11Display			= GetWindowManager()->GetX11Display();
	Screen*		x11DefaultScreen	= GetWindowManager()->GetX11DefaultScreen();
	::Window	x11RootWindow		= GetWindowManager()->GetX11RootWindow();
	
	//---------------------------------------------------------
	// XVisualInfo を取得する
	//		ここでは GLX の API を使用し、OpenGL で使いたいサーフェイスフォーマットから
	//		XVisualInfo を取得している。
	//		OpenGL 使わない場合は XMatchVisualInfo() 等、他にも取得する手段はある。
	//
	//		ちなみに、glfw はユーザーの指定や、環境が拡張機能をサポートしているかをチェックし、
	//		文字コード自動判別みたいに各 Visual 候補にスコアを振って、
	//		ベストな Visual を決めようとしていた。
	//		そこまでやるかは今後の要望しだいで。とりあえず一番ベーシックな A8R8G8B、D24S8 で取得する。
	//		※glfx では glXChooseVisual は使っていない。glXGetFBConfigs か、拡張が使えるときは glxChooseFBConfigSGIX。
	
	// http://earth.uni-muenster.de/~joergs/opengl/glXChooseVisual.html
	int32_t attributes[] =
	{
		//GLX_USE_GL,		// リファレンスには "無視される" とある。
		//GLX_LEVEL, 0,
		GLX_RGBA,			1,		// TrueColor 使用
		GLX_DOUBLEBUFFER,	1,		// ダブルバッファリング有効
		GLX_RED_SIZE,		8,		// R 8bit
		GLX_GREEN_SIZE,		8,		// G 8bit
		GLX_BLUE_SIZE,		8,		// B 8bit
		GLX_ALPHA_SIZE,		8,		// A 8bit
		GLX_DEPTH_SIZE,		24,		// 深度値 24bit
		GLX_STENCIL_SIZE,	8,		// ステンシル 8bit
		//GLX_SAMPLES,        MultiSamples,	// マルチサンプリング (アンチエイリアス)
		None
	};
	
	// http://manpages.ubuntu.com/manpages/gutsy/ja/man3/glXChooseVisual.3x.html
	// http://www.wakhok.ac.jp/~tatsuo/sen96/4shuu/section1.html
	XVisualInfo* visual = glXChooseVisual(x11Display, x11DefaultScreen, attributes);
	
	//---------------------------------------------------------
	// カラーマップを選択する。
	// 		カラーマップとは、ピクセルフォーマットのようなもので、256色 とか 65535色等様々なパレットが存在している。
	// 		これの実態はサーバ側にあり、XCreateColormap() は指定された visual から最適なカラーマップの ID を返している。そんなイメージ。
	// 		このカラーマップを XCreateWindow() に指定することで、ウィンドウのピクセルフォーマットを決定する。
	Colormap colorMap = XCreateColormap(x11Display, x11RootWindow, visual->visual, AllocNone);
	
	//---------------------------------------------------------
	// ウィンドウの属性 (Win32 のウィンドウスタイルみたいなもの)
	//		http://homepage3.nifty.com/rio_i/lab/xlib/015attribute.htm
	XSetWindowAttributes winAttr;
	winAttr.colormap = colorMap;
	winAttr.border_pixel = 0;
	winAttr.override_redirect = False;
	
	// Xサーバからどのイベントを受け取りたいのかを指定する
	winAttr.event_mask = ExposureMask | KeyPressMask | ButtonPressMask | StructureNotifyMask;
	
	//---------------------------------------------------------
	// ウィンドウを作る
	m_x11Window = XCreateWindow(
		x11Display,
		x11RootWindow,
		0, 0,
		m_clientSize.Width,
		m_clientSize.Height,
		0,                  // Border width
		visual->depth,      // Color depth
		InputOutput,
		visual->visual,
		CWBorderPixel | CWColormap | CWEventMask | CWOverrideRedirect,	// XSetWindowAttributes のどの部分を考慮するか
		&mWindowAttributes );
	
	
	XFree( visual );
	
	SetVisible(true);
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
X11Window::~X11Window()
{
	if (m_x11Window)
	{
		XDestroyWindow(GetWindowManager()->GetX11Display(), m_x11Window);
		m_x11Window = 0;
	}
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void X11Window::SetFullScreenEnabled(bool flag)
{
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void X11Window::CaptureMouse()
{
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void X11Window::ReleaseMouseCapture()
{
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void X11Window::SetVisible(bool show)
{
	// http://homepage3.nifty.com/rio_i/lab/xlib/001window.htm
	if (show)
	{
		XMapWindow( mXDisplay, mXWindow );
		XFlush( mXDisplay );
	}
	else
	{
		XUnmapWindow( mXDisplay, mXWindow );
		XFlush( mXDisplay );
	}
}

} // namespace Platform
} // namespace Lumino